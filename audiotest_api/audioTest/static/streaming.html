<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ğŸ§ ì‹¤ì‹œê°„ ìŒì„± ìŠ¤íŠ¸ë¦¬ë°</title>
  <style>
    /* ========== ê¸°ë³¸ ìŠ¤íƒ€ì¼ ========== */
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 24px; }
    h1 { margin: 0; }
    button { padding: 10px 14px; border-radius: 8px; border: 1px solid #ccc; margin-right: 8px; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }

    /* ========== ëª¨ë“œ ì„ íƒ ë²„íŠ¼ ========== */
    .mode-btn { background: #f0f0f0; }
    .mode-btn.active { background: #2196f3; color: white; border-color: #2196f3; }

    /* ========== í—¤ë” & ìƒíƒœ ì¸ë””ì¼€ì´í„° ========== */
    .header-container { display: flex; align-items: center; gap: 16px; margin-bottom: 20px; }
    .status-indicator { width: 24px; height: 24px; border-radius: 50%; background-color: #ccc; transition: background-color 0.3s ease; box-shadow: 0 0 8px rgba(0, 0, 0, 0.1); }
    .status-indicator.silent { background-color: #ffc107; box-shadow: 0 0 12px rgba(255, 193, 7, 0.6); }
    .status-indicator.speech { background-color: #4caf50; box-shadow: 0 0 12px rgba(76, 175, 80, 0.6); }
    .status-indicator.finished { background-color: #f44336; box-shadow: 0 0 12px rgba(244, 67, 54, 0.6); }
    .status-label { font-size: 12px; color: #666; margin-top: 4px; }

    /* ========== ë§ˆì´í¬ ì •ë³´ ========== */
    .mic-info { margin-top: 16px; padding: 12px; background: #f5f5f5; border-radius: 8px; border: 1px solid #ddd; }
    .mic-device { font-size: 13px; color: #333; margin-bottom: 8px; font-weight: 500; }
    .mic-level-container { display: flex; align-items: center; gap: 10px; }
    .mic-level-label { font-size: 12px; color: #666; min-width: 60px; }
    .mic-level-bar { flex: 1; height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden; }
    .mic-level-fill { height: 100%; background: linear-gradient(90deg, #4caf50 0%, #8bc34a 50%, #ffc107 75%, #ff5722 100%); width: 0%; transition: width 0.1s ease; }
    .mic-level-value { font-size: 12px; color: #666; min-width: 40px; text-align: right; }

    /* ========== íŒŒì¼ ì—…ë¡œë“œ ì˜ì—­ ========== */
    .file-upload-area { margin-top: 12px; padding: 16px; background: #e3f2fd; border-radius: 8px; border: 2px dashed #2196f3; }
    .file-upload-area input[type="file"] { margin-bottom: 10px; }

    /* ========== ìƒíƒœ í…ìŠ¤íŠ¸ ========== */
    #status { white-space: pre-line; margin-top: 12px; padding: 10px; background: #f0f0f0; border-radius: 4px; min-height: 60px; font-size: 14px; }
  </style>
</head>
<body>

  <!-- ========== í—¤ë” ì˜ì—­ ========== -->
  <div class="header-container">
    <div>
      <div class="status-indicator" id="statusIndicator"></div>
      <div class="status-label" id="statusLabel">ëŒ€ê¸° ì¤‘</div>
    </div>
    <h1>ğŸ§ ì‹¤ì‹œê°„ ìŒì„± ìŠ¤íŠ¸ë¦¬ë°</h1>
  </div>

  <!-- ========== ëª¨ë“œ ì„ íƒ ì˜ì—­ ========== -->
  <div style="margin-bottom: 12px;">
    <button id="streamModeBtn" class="mode-btn active">ğŸ™ï¸ ìŠ¤íŠ¸ë¦¬ë°</button>
    <button id="fileModeBtn" class="mode-btn">ğŸ“ íŒŒì¼</button>
  </div>

  <!-- ========== ìŠ¤íŠ¸ë¦¬ë° ëª¨ë“œ ë²„íŠ¼ ========== -->
  <div id="streamControls">
    <button id="startBtn">ë…¹ìŒ ì‹œì‘</button>
    <button id="stopBtn" disabled>ë…¹ìŒ ì¤‘ì§€</button>
  </div>

  <!-- ========== íŒŒì¼ ëª¨ë“œ ì—…ë¡œë“œ ì˜ì—­ ========== -->
  <div id="fileUploadArea" class="file-upload-area" style="display: none;">
    <input type="file" id="audioFile" accept=".wav" />
    <button id="uploadBtn">ğŸ“¤ ì—…ë¡œë“œ & ì „ì‚¬</button>
  </div>

  <!-- ========== ë§ˆì´í¬ ì •ë³´ ì˜ì—­ ========== -->
  <div class="mic-info" id="micInfo" style="display: none;">
    <div class="mic-device" id="micDevice">ğŸ¤ ë§ˆì´í¬: ê°ì§€ ì¤‘...</div>
    <div class="mic-level-container">
      <span class="mic-level-label">ì…ë ¥ ê°ë„:</span>
      <div class="mic-level-bar">
        <div class="mic-level-fill" id="micLevelFill"></div>
      </div>
      <span class="mic-level-value" id="micLevelValue">0%</span>
    </div>
  </div>

  <!-- ========== ìƒíƒœ í‘œì‹œ ì˜ì—­ ========== -->
  <div id="status">ëŒ€ê¸° ì¤‘...</div>
  <div style="margin-top: 20px;">
    <h3 style="margin: 0 0 10px 0; font-size: 14px;">ğŸ“Š ì²­í¬ íŒŒí˜•</h3>
    <canvas id="waveformCanvas" width="800" height="120" style="border: 1px solid #ddd; border-radius: 4px; background: #fafafa;"></canvas>
  </div>

  <script>
    // ========================================
    // ì„¤ì •
    // ========================================
    const COMM_URL = 'http://127.0.0.1:8000';

    // ========================================
    // DOM ìš”ì†Œ
    // ========================================
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const status = document.getElementById('status');
    const statusIndicator = document.getElementById('statusIndicator');
    const statusLabel = document.getElementById('statusLabel');
    const micInfo = document.getElementById('micInfo');
    const micDevice = document.getElementById('micDevice');
    const micLevelFill = document.getElementById('micLevelFill');
    const micLevelValue = document.getElementById('micLevelValue');
    const waveformCanvas = document.getElementById('waveformCanvas');
    const waveformCtx = waveformCanvas.getContext('2d');
    const streamModeBtn = document.getElementById('streamModeBtn');
    const fileModeBtn = document.getElementById('fileModeBtn');
    const streamControls = document.getElementById('streamControls');
    const fileUploadArea = document.getElementById('fileUploadArea');
    const audioFile = document.getElementById('audioFile');
    const uploadBtn = document.getElementById('uploadBtn');

    // ========================================
    // ìƒíƒœ ë³€ìˆ˜
    // ========================================
    let sessionId;
    let seq = 0;
    let isRecording = false;
    let audioContext;
    let analyser;
    let microphone;
    let workletNode;
    let animationId;
    let stream;
    let currentMode = 'chunk';  // 'chunk' ë˜ëŠ” 'file'

    // ========================================
    // ëª¨ë“œ ì „í™˜
    // ========================================
    streamModeBtn.addEventListener('click', () => {
      currentMode = 'chunk';
      streamModeBtn.classList.add('active');
      fileModeBtn.classList.remove('active');
      streamControls.style.display = 'block';
      fileUploadArea.style.display = 'none';
      status.textContent = 'ëŒ€ê¸° ì¤‘...';
      updateIndicator('Reset');
    });

    fileModeBtn.addEventListener('click', () => {
      currentMode = 'file';
      fileModeBtn.classList.add('active');
      streamModeBtn.classList.remove('active');
      streamControls.style.display = 'none';
      fileUploadArea.style.display = 'block';
      micInfo.style.display = 'none';
      status.textContent = 'WAV íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.';
      updateIndicator('Reset');
    });

    // ========================================
    // íŒŒì¼ ì—…ë¡œë“œ ì²˜ë¦¬
    // ========================================
    uploadBtn.addEventListener('click', async () => {
      const file = audioFile.files[0];
      
      if (!file) {
        status.textContent = 'âŒ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.';
        return;
      }
      
      if (!file.name.endsWith('.wav')) {
        status.textContent = 'âŒ WAV íŒŒì¼ë§Œ ì§€ì›í•©ë‹ˆë‹¤.';
        return;
      }
      
      status.textContent = 'ğŸ”„ ì „ì‚¬ ì¤‘...';
      updateIndicator('Speech');
      uploadBtn.disabled = true;
      
      const startRes = await fetch(`${COMM_URL}/start`, { method: 'POST' });
      const startData = await startRes.json();

      const formData = new FormData();
      formData.append('sessionId', startData.sessionId);
      formData.append('chunk', file);
      formData.append('mode', 'file');
      
      try {
        const res = await fetch(`${COMM_URL}/ingest-chunk`, {
          method: 'POST',
          body: formData
        });
        
        const data = await res.json();
        
        if (data.status === 'Finished') {
          status.textContent = `âœ… ê²°ê³¼: ${data.text || '(í…ìŠ¤íŠ¸ ì—†ìŒ)'}`;
          updateIndicator('Finished');
        } else {
          status.textContent = `âŒ ì˜¤ë¥˜: ${data.detail || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`;
          updateIndicator('Reset');
        }
      } catch (err) {
        status.textContent = `âŒ ì „ì†¡ ì‹¤íŒ¨: ${err.message}`;
        updateIndicator('Reset');
      } finally {
        uploadBtn.disabled = false;
      }
    });

    // ========================================
    // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
    // ========================================
    
    // ìƒíƒœ ì¸ë””ì¼€ì´í„° ì—…ë°ì´íŠ¸
    function updateIndicator(statusValue) {
      statusIndicator.classList.remove('silent', 'speech', 'finished');
      
      switch(statusValue) {
        case 'Silent':
          statusIndicator.classList.add('silent');
          statusLabel.textContent = 'ğŸŸ¡ ë¬´ìŒ';
          break;
        case 'Speech':
          statusIndicator.classList.add('speech');
          statusLabel.textContent = 'ğŸŸ¢ ìŒì„± ê°ì§€';
          break;
        case 'Finished':
          statusIndicator.classList.add('finished');
          statusLabel.textContent = 'ğŸ”´ ì™„ë£Œ';
          break;
        default:
          statusLabel.textContent = 'âšª ëŒ€ê¸° ì¤‘';
      }
    }


    // ========================================
    // íŒŒí˜• ê·¸ë¦¬ê¸°
    // ========================================
    function drawWaveform(buffer) {
      const int16Array = new Int16Array(buffer);
      const width = waveformCanvas.width;
      const height = waveformCanvas.height;
      const centerY = height / 2;
      
      // ë°°ê²½
      waveformCtx.fillStyle = '#fafafa';
      waveformCtx.fillRect(0, 0, width, height);
      
      // ì¤‘ì•™ì„ 
      waveformCtx.strokeStyle = '#ddd';
      waveformCtx.beginPath();
      waveformCtx.moveTo(0, centerY);
      waveformCtx.lineTo(width, centerY);
      waveformCtx.stroke();
      
      // íŒŒí˜•
      waveformCtx.strokeStyle = '#2196f3';
      waveformCtx.lineWidth = 1;
      waveformCtx.beginPath();
      
      const step = Math.ceil(int16Array.length / width);
      
      for (let i = 0; i < width; i++) {
        const idx = i * step;
        if (idx < int16Array.length) {
          const sample = int16Array[idx];
          const y = centerY - (sample / 32768) * centerY * 0.9;
          
          if (i === 0) {
            waveformCtx.moveTo(i, y);
          } else {
            waveformCtx.lineTo(i, y);
          }
        }
      }
      
      waveformCtx.stroke();
      
      // ì •ë³´ í‘œì‹œ
      let maxVal = 0;
      for (let i = 0; i < int16Array.length; i++) {
        const absVal = Math.abs(int16Array[i]);
        if (absVal > maxVal) maxVal = absVal;
      }
      
      waveformCtx.fillStyle = '#666';
      waveformCtx.font = '10px monospace';
      waveformCtx.fillText(`ìƒ˜í”Œ: ${int16Array.length} | ìµœëŒ€: ${maxVal}`, 5, 12);
    }

    // ========================================
    // ë§ˆì´í¬ ë ˆë²¨ ëª¨ë‹ˆí„°ë§
    // ========================================
    function updateMicLevel() {
      if (!analyser || !isRecording) return;

      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(dataArray);

      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sum += dataArray[i];
      }
      const average = sum / dataArray.length;
      const percentage = Math.min(100, (average / 255) * 150);

      micLevelFill.style.width = `${percentage}%`;
      micLevelValue.textContent = `${Math.round(percentage)}%`;

      animationId = requestAnimationFrame(updateMicLevel);
    }

    // ========================================
    // ë¦¬ì†ŒìŠ¤ ì •ë¦¬
    // ========================================
    function stopRecording(message = '') {
      isRecording = false;
      
      // ì• ë‹ˆë©”ì´ì…˜ ì •ë¦¬
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      // Worklet ì •ë¦¬
      if (workletNode) {
        workletNode.port.postMessage('stop');
        workletNode.port.onmessage = null;
        workletNode.disconnect();
        workletNode = null;
      }
      
      // ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }

      // ì˜¤ë””ì˜¤ ë…¸ë“œ ì •ë¦¬
      if (microphone) {
        microphone.disconnect();
        microphone = null;
      }
      if (analyser) {
        analyser.disconnect();
        analyser = null;
      }
      
      // AudioContext ì •ë¦¬
      if (audioContext && audioContext.state !== 'closed') {
        audioContext.close();
        audioContext = null;
      }
      
      // UI ì´ˆê¸°í™”
      micInfo.style.display = 'none';
      micLevelFill.style.width = '0%';
      micLevelValue.textContent = '0%';
      startBtn.disabled = false;
      stopBtn.disabled = true;
      
      if (message) {
        status.textContent = message;
      }
    }

    // ========================================
    // PCM ì²­í¬ ì „ì†¡
    // ========================================
    async function sendPCMChunk(buffer) {
      if (!isRecording) return;

      drawWaveform(buffer);

      const currentSeq = seq++;
      const chunkSize = buffer.byteLength;
      
      // FormData ìƒì„±
      const blob = new Blob([buffer], { type: 'application/octet-stream' });
      const formData = new FormData();
      formData.append('sessionId', sessionId);
      formData.append('chunk', blob, `chunk-${currentSeq}.raw`);
      formData.append('mode', 'chunk');

      try {
        const res = await fetch(`${COMM_URL}/ingest-chunk`, { 
          method: 'POST', 
          body: formData 
        });
        
        // ì‘ë‹µ ì²˜ë¦¬
        if (res.status === 200) {
          const data = await res.json();
          
          if (data.status) {
            updateIndicator(data.status);
          }

          if (data.status === 'Finished') {
            status.textContent = `âœ… ì™„ë£Œ: ${data.text || ''}`;
            setTimeout(() => {
              stopRecording('ëŒ€ê¸° ì¤‘...');
              updateIndicator('Reset');
            }, 2000);
          }
        }
        
      } catch (err) {
        console.error("ì „ì†¡ ì‹¤íŒ¨:", err);
      }
    }

    // ========================================
    // ë…¹ìŒ ì‹œì‘
    // ========================================
    startBtn.addEventListener('click', async () => {
      try {
        // 1. ë§ˆì´í¬ ìŠ¤íŠ¸ë¦¼ íšë“
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // ë§ˆì´í¬ ì •ë³´ í‘œì‹œ
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioDevice = stream.getAudioTracks()[0].getSettings();
        const device = devices.find(d => d.kind === 'audioinput' && d.deviceId === audioDevice.deviceId);
        micDevice.textContent = `ğŸ¤ ${device ? device.label : 'ê¸°ë³¸ ë§ˆì´í¬'}`;
        micInfo.style.display = 'block';

        // 2. AudioContext ìƒì„± & Worklet ë¡œë“œ
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        await audioContext.audioWorklet.addModule('/static/processor.js?v=' + Date.now());

        // 3. ì˜¤ë””ì˜¤ ë…¸ë“œ ìƒì„± & ì—°ê²°
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        microphone = audioContext.createMediaStreamSource(stream);
        workletNode = new AudioWorkletNode(audioContext, 'audio-stream-processor');

        microphone.connect(analyser);
        microphone.connect(workletNode);

        // 4. Worklet ë°ì´í„° ìˆ˜ì‹ 
        workletNode.port.onmessage = (event) => {
          sendPCMChunk(event.data);
        };
        
        // 5. ì„¸ì…˜ ì‹œì‘
        const startRes = await fetch(`${COMM_URL}/start`, { method: 'POST' });
        const startData = await startRes.json();
        sessionId = startData.sessionId;
        seq = 0;

        // 6. UI ì—…ë°ì´íŠ¸
        status.textContent = `ë…¹ìŒ ì¤‘... (ì„¸ì…˜: ${sessionId.substring(0, 8)}...)`;
        updateIndicator('Silent');
        isRecording = true;
        updateMicLevel();

        startBtn.disabled = true;
        stopBtn.disabled = false;

      } catch (err) {
        status.textContent = `ì—ëŸ¬: ${err.message}`;
        console.error("ì—ëŸ¬:", err);
        stopRecording();
      }
    });

    // ========================================
    // ë…¹ìŒ ì¤‘ì§€
    // ========================================
    stopBtn.addEventListener('click', () => {
      stopRecording('ìˆ˜ë™ ì¤‘ì§€');
      updateIndicator('Reset');
    });

    // ========================================
    // í˜ì´ì§€ ì´íƒˆ ì‹œ ì •ë¦¬
    // ========================================
    window.addEventListener('beforeunload', () => {
      if (workletNode) {
        workletNode.port.postMessage('stop');
      }
      stopRecording();
    });

    document.addEventListener('visibilitychange', () => {
      if (document.hidden && isRecording) {
        stopRecording('í˜ì´ì§€ ìˆ¨ê¹€');
        updateIndicator('Reset');
      }
    });

  </script>
</body>
</html>